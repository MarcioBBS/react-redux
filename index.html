<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>React - Redux</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/redux/3.7.2/redux.min.js"></script>
    <script src="https://unpkg.com/react@16.3.0-alpha.1/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@16.3.0-alpha.1/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>
  </head>
  <body style="padding: 20px">
    <h1>React - Redux</h1>
    <hr />
    <br />

    <div class="list">
      <input type="text" name="todo" id="todo" placeholder="Add Todo" />
      <button id="todoBtn">Add Todo</button>
      <ul id="todos"></ul>
    </div>

    <div class="list">
      <input type="text" name="goal" id="goal" placeholder="Add Goal" />
      <button id="goalBtn">Add Goal</button>
      <ul id="goals"></ul>
    </div>

    <hr />
    <div id="app"></div>

    <script>
      // Create unique ID
      function generateId() {
        return Math.random().toString(36).substring(2) + new Date().getTime().toString(36);
      }

      /*** App Code ***/

      // Constants Events
      const ADD_TODO = "ADD_TODO";
      const REMOVE_TODO = "REMOVE_TODO";
      const TOGGLE_TODO = "TOGGLE_TODO";
      const ADD_GOAL = "ADD_GOAL";
      const REMOVE_GOAL = "REMOVE_GOAL";

      // According to my inverstor, bitcoin is not a good idea, so we can't add bitcoin word at the goal and todo list.
      // This function checks is the user try to add a bitcoin to the todo and goal list.
      // next is the next middleware in line, if we have more than one middleware or dispatch()
      const checker = store => next => action => {
        if (action.type === ADD_TODO && action.todo.name.toLowerCase().includes("bitcoin")) {
          return alert("Nope. that is not a good idea");
        }

        if (action.type === ADD_GOAL && action.goal.name.toLowerCase().includes("bitcoin")) {
          return alert("Nope. that is not a good idea");
        }

        return next(action);
      };

      // Logger Middleware
      // VERY IMPORTANT to use this Middleware to intercept all Dispatch calls and log out what the Action is that being Dispatched and what the sate changes to after the Reducer has run. This is very usefull during the App development.
      const logger = store => next => action => {
        console.group(action.type);
         console.log('The action: ', action);
         const result = next(action);
         console.log('The new state: ', store.getState());
        console.groupEnd();
        return result;
      };

      // Create the STORE
      const store = Redux.createStore(
        Redux.combineReducers({
          todos,
          goals,
        }),
        Redux.applyMiddleware(checker, logger)
      );

      // Action Creators - Are functions that create and return Actions objects
      const addTodoAction = todo => ({ type: ADD_TODO, todo }); // Add todo event

      const removeTodoAction = id => ({ type: REMOVE_TODO, id }); // Remove todo event

      const toggleTodoAction = id => ({ type: TOGGLE_TODO, id }); // Toggle todo event

      const addGoalAction = goal => ({ type: ADD_GOAL, goal }); // Add goal event

      const removeGoalAction = id => ({ type: REMOVE_GOAL, id }); // Remove goal event
      // End - Action Creators

      /*** Reducers - It's a pure function that takes the current state and an action and returns the new state of the application - It reduces to a brand new state   ***/
      // App todos - Reducer
      function todos(state = [], action) {
        switch (action.type) {
          case ADD_TODO:
            return [...state, action.todo];
          case REMOVE_TODO:
            return state.filter(todo => todo.id !== action.id);
          case TOGGLE_TODO:
            return state.map(todo => (todo.id !== action.id ? todo : Object.assign({}, todo, { complete: !todo.complete })));
          default:
            return state;
        }
      }

      // App goals - Reducer
      function goals(state = [], action) {
        switch (action.type) {
          case ADD_GOAL:
            return [...state, action.goal];
          case REMOVE_GOAL:
            return state.filter(goal => goal.id !== action.id);
          default:
            return state;
        }
      }

      // Lsiten for changes
      // Add the Todos and Goals items to the DOM
      store.subscribe(() => {
        const { goals, todos } = store.getState();

        // Reset the unorder list
        document.querySelector("#goals").innerHTML = "";
        document.querySelector("#todos").innerHTML = "";

        // Add items to the DOM
        goals.forEach(renderGoalToDOM);
        todos.forEach(renderTodoToDOM);
      });
      /*** END -  App Code ***/

      /*** DOM manipulation ***/
      // Add Todo
      function addTodo() {
        // Get the value from the UI
        const input = document.querySelector("#todo");
        const name = input.value;
        input.value = ""; // Reset the value

        // Add the todo to the state
        // The dispatch() method is responsible for emmiting the Action to the Store
        store.dispatch(addTodoAction({
            name,
            complete: false,
            id: generateId(),
          })
        );
      }

      // Add Goal
      function addGoal() {
        // Get the value from the UI
        const input = document.querySelector("#goal");
        const name = input.value;
        input.value = ""; // Reset the value

        // Add the goal to the state
        // The dispatch() method is responsible for emmiting the Action to the Store
        store.dispatch(addGoalAction({
            name,
            id: generateId(),
          })
        );
      }

      //Add new Todo
      document.querySelector("#todoBtn").addEventListener("click", addTodo);
      //Add new Goal
      document.querySelector("#goalBtn").addEventListener("click", addGoal);

      /**
       * Create button to remove item from the list
       * @param {callback function} onClick
       * @returns the button with the event listener embeeded
       */
      function createRemoveButton(onClick) {
        const removeBtn = document.createElement("button");
        removeBtn.innerHTML = " X ";
        removeBtn.addEventListener("click", onClick);
        return removeBtn;
      }

      function renderTodoToDOM(todo) {
        const node = document.createElement("li");
        const text = document.createTextNode(todo.name);
        const removeBtn = createRemoveButton(() => store.dispatch(removeTodoAction(todo.id)));

        node.appendChild(text);
        node.appendChild(removeBtn);

        node.style.textDecoration = todo.complete ? "line-through" : "none";
        node.addEventListener("click", () => store.dispatch(toggleTodoAction(todo.id)));

        document.querySelector("#todos").appendChild(node);
      }

      function renderGoalToDOM(goal) {
        const node = document.createElement("li");
        const text = document.createTextNode(goal.name);
        const removeBtn = createRemoveButton(() => store.dispatch(removeGoalAction(goal.id)));

        node.appendChild(text);
        node.appendChild(removeBtn);

        document.querySelector("#goals").appendChild(node);
      }
      /*** END- DOM manipulation ***/
    </script>

    <script type="text/babel">
      // REACT

      const List = props => {
        return (
          <ul>
            <li>LIST</li>
          </ul>
        );
      };

      class Todos extends React.Component {
        addItem = e => {
          e.preventDefault();
          const name = this.inputElement.value;
          this.inputElement.value = ""; // Reset the input value

          // The dispatch() method is responsible for emmiting the Action to the Store
          this.props.store.dispatch(addTodoAction({
            name,
            complete: false,
            id: generateId()
          }));
        }

        render() {
          return (
            <div>
              <h1>Todo List</h1>
              <input
                type="text"
                placeholder="Add Todo"
                // ref provides a way to access DOM nodes or React elements created in the render method.
                // We're storing here a reference of the [input] DOM element in the [this.inputElement] instance of the [Todos] class
                ref={ input => this.inputElement = input } 
              />
              <button onClick={ this.addItem }>Add Todo</button>
              <List />
            </div>
          );
        }
      }

      class Goals extends React.Component {
        addItem = e => {
           e.preventDefault();
           const name = this.inputElement.value;
           this.inputElement.value = "";

           this.props.store.dispatch(addGoalAction({
            name,
            id: generateId(),
            }));
        } 

        render() {
          return (
            <div>
              <h1>Goals List</h1>
              <input 
               type='text'
               placeholder='Add Goal'
               ref={ input => this.inputElement = input}
              />
              <button onClick= { this.addItem } >Add Goal</button>
              <List />
            </div>
          );
        }
      }

      class App extends React.Component {
        componentDidMount()  {
           const { store } = this.props;

           
           store.subscribe(() => this.forceUpdate() ); // forceUpdate() is typically an anti-pattern but only used here for this specific case 
        }

        render() {
           const { store } = this.props;
           const { todos, goals } = store.getState();
          return (
            <div>
              <Todos todos={ todos } store={ this.props.store }/>
              <Goals goals={ goals } store={ this.props.store }/>
            </div>
          );
        }
      }

      ReactDOM.render(<App store={store}/>, document.querySelector("#app"));
    </script>
  </body>
</html>
